# 백준 2458번 문제 - 키 순서
## 플로이드 마샬이라는 알고리즘 쓰면 가능하다해서 위에 추가
``` java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.StringTokenizer;

public class B2458 {
	static class Node {
		int cnt;
		int rcnt;
		public Node(int cnt, int rcnt) {
			super();
			this.cnt = cnt;
			this.rcnt = rcnt;
		}
		
	}
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken()) + 1;
		int m = Integer.parseInt(st.nextToken());
		// 토폴로지 두번 양방향 보고 가운데서 값이 맞으면 될듯.. 역방향 그래프 만들어서 먼저 cnt 채우고 다음에 정방향 가면서 카운터랑 합을 봐야할듯
		
		// 토폴로지로 풀려고 하니 안됨.. 그냥 하나 노드마다 순차적으로 bfs돌리는 식으로 .. cnt도 reverse랑 나눌필요없음 이렇게 할꺼면
		List<Integer>[] people = new LinkedList[n];
		List<Integer>[] rpeople = new LinkedList[n];
		
		// 그래서 이런 Node 데이터 형을 만들었음
		Node[] pInfo = new Node[n];
		for (int i = 1; i < n; i++) {
			people[i] = new LinkedList<>();
			rpeople[i] = new LinkedList<>();
			pInfo[i] = new Node(0,0);
		}
		//일단 입력부터 받어
		int ti1,ti2;
		for (int i = 0; i < m; i++) {
			st = new StringTokenizer(br.readLine());
			ti1 = Integer.parseInt(st.nextToken());
			ti2 = Integer.parseInt(st.nextToken());
			//역방향
			rpeople[ti2].add(ti1);
			//정방향
			people[ti1].add(ti2);
		}
		boolean[] v;
		int ti;
		int rst = 0;
		for (int i = 1; i < n; i++) {
			//visited체크하고
			v = new boolean[n+1];
			//역방향 먼저 따라가
			Queue<Integer> trace = new LinkedList<>();
			trace.offer(i);
			v[i] = true;
			while(!trace.isEmpty()) {
				ti = trace.poll();
				for (int j : rpeople[ti]) {
					if (v[j]) {
						continue;
					}
					trace.offer(j);
					v[j] = true;
					pInfo[i].rcnt++;
				}
			}
			//정방향 따라가
			trace.offer(i);
			while(!trace.isEmpty()) {
				ti = trace.poll();
				for (int j : people[ti]) {
					if (v[j]) {
						continue;
					}
					trace.offer(j);
					v[j] = true;
					pInfo[i].cnt++;
				}
			}
			//두개 숫자 합이 n-1이면 가능 > n-2로 해야함 위에 1더햇으니까
			if ((pInfo[i].cnt + pInfo[i].rcnt) == n-2) {
				rst++;
			}
		}
		System.out.println(rst);
	}
}
```
